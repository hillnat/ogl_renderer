\hypertarget{namespace_assimp}{}\doxysection{Assimp Namespace Reference}
\label{namespace_assimp}\index{Assimp@{Assimp}}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{struct_assimp_1_1_attachment_info}{Attachment\+Info}}
\begin{DoxyCompactList}\small\item\em Helper data structure for \mbox{\hyperlink{class_assimp_1_1_scene_combiner}{Scene\+Combiner}}. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_assimp_1_1_base_importer}{Base\+Importer}}
\item 
class \mbox{\hyperlink{class_assimp_1_1_bitmap}{Bitmap}}
\item 
class \mbox{\hyperlink{class_assimp_1_1_blob_i_o_stream}{Blob\+IOStream}}
\item 
class \mbox{\hyperlink{class_assimp_1_1_blob_i_o_system}{Blob\+IOSystem}}
\item 
struct \mbox{\hyperlink{struct_assimp_1_1_bone_with_hash}{Bone\+With\+Hash}}
\begin{DoxyCompactList}\small\item\em Helper data structure for \mbox{\hyperlink{class_assimp_1_1_scene_combiner_aa42d5370510db89cbdd739617a617d4e}{Scene\+Combiner\+::\+Merge\+Bones}}. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_assimp_1_1_byte_swap}{Byte\+Swap}}
\item 
class \mbox{\hyperlink{class_assimp_1_1_comment_remover}{Comment\+Remover}}
\begin{DoxyCompactList}\small\item\em Helper class to remove single and multi line comments from a file. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_assimp_1_1_default_i_o_stream}{Default\+IOStream}}
\begin{DoxyCompactList}\small\item\em Default IO implementation, use standard IO operations. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_assimp_1_1_default_i_o_system}{Default\+IOSystem}}
\item 
class \mbox{\hyperlink{class_assimp_1_1_default_logger}{Default\+Logger}}
\begin{DoxyCompactList}\small\item\em CPP-\/\+API\+: Primary logging facility of \mbox{\hyperlink{namespace_assimp}{Assimp}}. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_assimp_1_1_exporter}{Exporter}}
\item 
class \mbox{\hyperlink{class_assimp_1_1_export_properties}{Export\+Properties}}
\item 
struct \mbox{\hyperlink{struct_assimp_1_1find__node__by__name__predicate}{find\+\_\+node\+\_\+by\+\_\+name\+\_\+predicate}}
\begin{DoxyCompactList}\small\item\em Will find a node by its name. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_assimp_1_1_importer}{Importer}}
\item 
class \mbox{\hyperlink{class_assimp_1_1_i_o_stream}{IOStream}}
\begin{DoxyCompactList}\small\item\em CPP-\/\+API\+: Class to handle file I/O for C++. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_assimp_1_1_i_o_stream_buffer}{IOStream\+Buffer}}
\item 
class \mbox{\hyperlink{class_assimp_1_1_i_o_system}{IOSystem}}
\begin{DoxyCompactList}\small\item\em CPP-\/\+API\+: Interface to the file system. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_assimp_1_1_line_splitter}{Line\+Splitter}}
\item 
class \mbox{\hyperlink{class_assimp_1_1_log_functions}{Log\+Functions}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{class_assimp_1_1_logger}{Logger}} class, which will extend the class by log-\/functions. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_assimp_1_1_logger}{Logger}}
\begin{DoxyCompactList}\small\item\em CPP-\/\+API\+: Abstract interface for logger implementations. \mbox{\hyperlink{namespace_assimp}{Assimp}} provides a default implementation and uses it for almost all logging stuff (\textquotesingle{}\mbox{\hyperlink{class_assimp_1_1_default_logger}{Default\+Logger}}\textquotesingle{}). This class defines just basic logging behavior and is not of interest for you. Instead, take a look at \#\+Default\+Logger. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_assimp_1_1_log_stream}{Log\+Stream}}
\begin{DoxyCompactList}\small\item\em CPP-\/\+API\+: Abstract interface for log stream implementations. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_assimp_1_1_memory_i_o_stream}{Memory\+IOStream}}
\item 
class \mbox{\hyperlink{class_assimp_1_1_memory_i_o_system}{Memory\+IOSystem}}
\begin{DoxyCompactList}\small\item\em Dummy IO system to read from a memory buffer. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{struct_assimp_1_1_node_attachment_info}{Node\+Attachment\+Info}}
\item 
struct \mbox{\hyperlink{struct_assimp_1_1_node_converter}{Node\+Converter}}
\begin{DoxyCompactList}\small\item\em Will convert an attribute to its int value. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_assimp_1_1_null_logger}{Null\+Logger}}
\begin{DoxyCompactList}\small\item\em CPP-\/\+API\+: Empty logging implementation. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_assimp_1_1_progress_handler}{Progress\+Handler}}
\begin{DoxyCompactList}\small\item\em CPP-\/\+API\+: Abstract interface for custom progress report receivers. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_assimp_1_1_scene_combiner}{Scene\+Combiner}}
\begin{DoxyCompactList}\small\item\em Static helper class providing various utilities to merge two scenes. It is intended as internal utility and NOT for use by applications. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{struct_assimp_1_1_scene_helper}{Scene\+Helper}}
\begin{DoxyCompactList}\small\item\em Utility for \mbox{\hyperlink{class_assimp_1_1_scene_combiner}{Scene\+Combiner}}. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_assimp_1_1_s_g_spatial_sort}{SGSpatial\+Sort}}
\item 
class \mbox{\hyperlink{class_assimp_1_1_skeleton_mesh_builder}{Skeleton\+Mesh\+Builder}}
\item 
class \mbox{\hyperlink{class_assimp_1_1_small_vector}{Small\+Vector}}
\begin{DoxyCompactList}\small\item\em Small vector with inplace storage. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_assimp_1_1_spatial_sort}{Spatial\+Sort}}
\item 
class \mbox{\hyperlink{class_assimp_1_1_standard_shapes}{Standard\+Shapes}}
\begin{DoxyCompactList}\small\item\em Helper class to generate vertex buffers for standard geometric shapes, such as cylinders, cones, boxes, spheres, elipsoids ... . \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_assimp_1_1_stream_reader}{Stream\+Reader}}
\item 
class \mbox{\hyperlink{class_assimp_1_1_stream_writer}{Stream\+Writer}}
\item 
class \mbox{\hyperlink{class_assimp_1_1_subdivider}{Subdivider}}
\item 
class \mbox{\hyperlink{class_assimp_1_1_t_xml_parser}{TXml\+Parser}}
\begin{DoxyCompactList}\small\item\em The Xml-\/\+Parser class. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{struct_assimp_1_1_vertex}{Vertex}}
\item 
class \mbox{\hyperlink{class_assimp_1_1_xml_node_iterator}{Xml\+Node\+Iterator}}
\begin{DoxyCompactList}\small\item\em This class declares an iterator to loop through all children of the root node. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_assimp_1_1_zip_archive_i_o_system}{Zip\+Archive\+IOSystem}}
\end{DoxyCompactItemize}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespace_assimp_acdd122cae88cee792338440e43d4f374}\label{namespace_assimp_acdd122cae88cee792338440e43d4f374}} 
using {\bfseries Ai\+Assert\+Handler} = void($\ast$)(const char $\ast$failed\+Expression, const char $\ast$file, int line)
\begin{DoxyCompactList}\small\item\em Signature of functions which handle assert violations. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_assimp_a2eb4315da2826d0a25ee9fd2e45d1a59}\label{namespace_assimp_a2eb4315da2826d0a25ee9fd2e45d1a59}} 
using {\bfseries UByte\+Buffer} = std\+::vector$<$ uint8\+\_\+t $>$
\item 
\mbox{\Hypertarget{namespace_assimp_aff2f770e8e73ef550d66f3674f66fdfb}\label{namespace_assimp_aff2f770e8e73ef550d66f3674f66fdfb}} 
using {\bfseries Byte\+Buffer} = std\+::vector$<$ int8\+\_\+t $>$
\item 
\mbox{\Hypertarget{namespace_assimp_ab47d29e283b76e1f746e5c7af78277a3}\label{namespace_assimp_ab47d29e283b76e1f746e5c7af78277a3}} 
typedef std\+::pair$<$ \mbox{\hyperlink{structai_bone}{ai\+Bone}} $\ast$, unsigned int $>$ {\bfseries Bone\+Src\+Index}
\item 
\mbox{\Hypertarget{namespace_assimp_a805919b898c0391a446495ee52067f42}\label{namespace_assimp_a805919b898c0391a446495ee52067f42}} 
typedef \mbox{\hyperlink{class_assimp_1_1_stream_reader}{Stream\+Reader}}$<$ true $>$ {\bfseries Stream\+Reader\+BE}
\item 
\mbox{\Hypertarget{namespace_assimp_ae1f004ccb8f551efc9c3249184f66eef}\label{namespace_assimp_ae1f004ccb8f551efc9c3249184f66eef}} 
typedef \mbox{\hyperlink{class_assimp_1_1_stream_reader}{Stream\+Reader}}$<$ false $>$ {\bfseries Stream\+Reader\+LE}
\item 
\mbox{\Hypertarget{namespace_assimp_a66d01581400aeccb77b6523bb6f40bc9}\label{namespace_assimp_a66d01581400aeccb77b6523bb6f40bc9}} 
typedef \mbox{\hyperlink{class_assimp_1_1_stream_reader}{Stream\+Reader}}$<$ true, true $>$ {\bfseries Stream\+Reader\+Any}
\item 
\mbox{\Hypertarget{namespace_assimp_aef34a2f32751e792f5e54bfa7deafd7b}\label{namespace_assimp_aef34a2f32751e792f5e54bfa7deafd7b}} 
typedef \mbox{\hyperlink{class_assimp_1_1_stream_writer}{Stream\+Writer}}$<$ true $>$ {\bfseries Stream\+Writer\+BE}
\item 
\mbox{\Hypertarget{namespace_assimp_a5b7ad422930729dfb8c36a1e79407bf4}\label{namespace_assimp_a5b7ad422930729dfb8c36a1e79407bf4}} 
typedef \mbox{\hyperlink{class_assimp_1_1_stream_writer}{Stream\+Writer}}$<$ false $>$ {\bfseries Stream\+Writer\+LE}
\item 
\mbox{\Hypertarget{namespace_assimp_a31923ade59707b02bfe834479bf9acda}\label{namespace_assimp_a31923ade59707b02bfe834479bf9acda}} 
typedef \mbox{\hyperlink{class_assimp_1_1_stream_writer}{Stream\+Writer}}$<$ true, true $>$ {\bfseries Stream\+Writer\+Any}
\item 
\mbox{\Hypertarget{namespace_assimp_af7fe906c227a19aea9aaf197846ee8fe}\label{namespace_assimp_af7fe906c227a19aea9aaf197846ee8fe}} 
using {\bfseries Xml\+Node} = pugi\+::xml\+\_\+node
\item 
\mbox{\Hypertarget{namespace_assimp_a39b031370e5aba8e0f587ee4b3c18214}\label{namespace_assimp_a39b031370e5aba8e0f587ee4b3c18214}} 
using {\bfseries Xml\+Attribute} = pugi\+::xml\+\_\+attribute
\item 
\mbox{\Hypertarget{namespace_assimp_ac1f9ddc766331a128a2d8b033b360a72}\label{namespace_assimp_ac1f9ddc766331a128a2d8b033b360a72}} 
using {\bfseries Xml\+Parser} = \mbox{\hyperlink{class_assimp_1_1_t_xml_parser}{TXml\+Parser}}$<$ pugi\+::xml\+\_\+node $>$
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespace_assimp_a49ad38ed2d9749f155deb93f0a524df8}\label{namespace_assimp_a49ad38ed2d9749f155deb93f0a524df8}} 
ASSIMP\+\_\+\+API void {\bfseries set\+Ai\+Assert\+Handler} (\mbox{\hyperlink{namespace_assimp_acdd122cae88cee792338440e43d4f374}{Ai\+Assert\+Handler}} handler)
\begin{DoxyCompactList}\small\item\em Set the assert handler. \end{DoxyCompactList}\item 
AI\+\_\+\+WONT\+\_\+\+RETURN ASSIMP\+\_\+\+API void \mbox{\hyperlink{namespace_assimp_a896afdcb6c8dc97c0b85edd74793d191}{default\+Ai\+Assert\+Handler}} (const char $\ast$failed\+Expression, const char $\ast$file, int line) AI\+\_\+\+WONT\+\_\+\+RETURN\+\_\+\+SUFFIX
\begin{DoxyCompactList}\small\item\em This issues a message to stderr and calls abort. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_assimp_aee0be0a7697ffab9038d27ffc6cb5065}\label{namespace_assimp_aee0be0a7697ffab9038d27ffc6cb5065}} 
ASSIMP\+\_\+\+API void {\bfseries ai\+Assert\+Violation} (const char $\ast$failed\+Expression, const char $\ast$file, int line)
\begin{DoxyCompactList}\small\item\em Dispatches an assert violation to the assert handler. \end{DoxyCompactList}\item 
ASSIMP\+\_\+\+API \mbox{\hyperlink{structai_anim_mesh}{ai\+Anim\+Mesh}} $\ast$ \mbox{\hyperlink{namespace_assimp_a0c3ea46ea110bbc5987def5503507112}{ai\+Create\+Anim\+Mesh}} (const \mbox{\hyperlink{structai_mesh}{ai\+Mesh}} $\ast$mesh, bool need\+Positions=true, bool need\+Normals=true, bool need\+Tangents=true, bool need\+Colors=true, bool need\+Tex\+Coords=true)
\item 
\mbox{\Hypertarget{namespace_assimp_a0b34bad3b9ad1b488391ede9b4f23c07}\label{namespace_assimp_a0b34bad3b9ad1b488391ede9b4f23c07}} 
unsigned int {\bfseries strtoul10} (const char $\ast$in, const char $\ast$$\ast$out=0)
\item 
\mbox{\Hypertarget{namespace_assimp_a1c1db8ffa6363c57660b3d1d0dc8ed3f}\label{namespace_assimp_a1c1db8ffa6363c57660b3d1d0dc8ed3f}} 
unsigned int {\bfseries strtoul8} (const char $\ast$in, const char $\ast$$\ast$out=0)
\item 
\mbox{\Hypertarget{namespace_assimp_a358486ae5448785a4eeb0b6d9ebe929b}\label{namespace_assimp_a358486ae5448785a4eeb0b6d9ebe929b}} 
unsigned int {\bfseries strtoul16} (const char $\ast$in, const char $\ast$$\ast$out=0)
\item 
\mbox{\Hypertarget{namespace_assimp_a6bb609222363ab9ba88298597056d65f}\label{namespace_assimp_a6bb609222363ab9ba88298597056d65f}} 
unsigned int {\bfseries Hex\+Digit\+To\+Decimal} (char in)
\item 
\mbox{\Hypertarget{namespace_assimp_a50f9e78be9d92b2140273c577d24ff47}\label{namespace_assimp_a50f9e78be9d92b2140273c577d24ff47}} 
uint8\+\_\+t {\bfseries Hex\+Octet\+To\+Decimal} (const char $\ast$in)
\item 
\mbox{\Hypertarget{namespace_assimp_a6712580fbbfe4f27e13815abf8e2a0e0}\label{namespace_assimp_a6712580fbbfe4f27e13815abf8e2a0e0}} 
int {\bfseries strtol10} (const char $\ast$in, const char $\ast$$\ast$out=0)
\item 
\mbox{\Hypertarget{namespace_assimp_a90b8b671fcfb5f9c2c1be40056cdef27}\label{namespace_assimp_a90b8b671fcfb5f9c2c1be40056cdef27}} 
unsigned int {\bfseries strtoul\+\_\+cppstyle} (const char $\ast$in, const char $\ast$$\ast$out=0)
\item 
\mbox{\Hypertarget{namespace_assimp_a0ceec2f2e3cbdd050b3a44a9384f4d0f}\label{namespace_assimp_a0ceec2f2e3cbdd050b3a44a9384f4d0f}} 
{\footnotesize template$<$typename Exception\+Type  = Deadly\+Import\+Error$>$ }\\uint64\+\_\+t {\bfseries strtoul10\+\_\+64} (const char $\ast$in, const char $\ast$$\ast$out=0, unsigned int $\ast$max\+\_\+inout=0)
\item 
\mbox{\Hypertarget{namespace_assimp_aa68dc5728b1b75a6010fc11e189a1f94}\label{namespace_assimp_aa68dc5728b1b75a6010fc11e189a1f94}} 
{\footnotesize template$<$typename Exception\+Type  = Deadly\+Import\+Error$>$ }\\int64\+\_\+t {\bfseries strtol10\+\_\+64} (const char $\ast$in, const char $\ast$$\ast$out=0, unsigned int $\ast$max\+\_\+inout=0)
\item 
{\footnotesize template$<$typename Real , typename Exception\+Type  = Deadly\+Import\+Error$>$ }\\const char $\ast$ \mbox{\hyperlink{namespace_assimp_a4b486541edb9e5bdda47cb9e73f9e877}{fast\+\_\+atoreal\+\_\+move}} (const char $\ast$c, Real \&out, bool check\+\_\+comma=true)
\item 
\mbox{\Hypertarget{namespace_assimp_a5528fa5dfe30cfbb445f48b469649ec8}\label{namespace_assimp_a5528fa5dfe30cfbb445f48b469649ec8}} 
{\footnotesize template$<$typename Exception\+Type  = Deadly\+Import\+Error$>$ }\\ai\+\_\+real {\bfseries fast\+\_\+atof} (const char $\ast$c)
\item 
\mbox{\Hypertarget{namespace_assimp_a94f5122c86d191932afa227e7a3fac30}\label{namespace_assimp_a94f5122c86d191932afa227e7a3fac30}} 
{\footnotesize template$<$typename Exception\+Type  = Deadly\+Import\+Error$>$ }\\ai\+\_\+real {\bfseries fast\+\_\+atof} (const char $\ast$c, const char $\ast$$\ast$cout)
\item 
\mbox{\Hypertarget{namespace_assimp_aa4cf660be5711cd91b09df17e5dcf5cc}\label{namespace_assimp_aa4cf660be5711cd91b09df17e5dcf5cc}} 
{\footnotesize template$<$typename Exception\+Type  = Deadly\+Import\+Error$>$ }\\ai\+\_\+real {\bfseries fast\+\_\+atof} (const char $\ast$$\ast$inout)
\item 
\mbox{\Hypertarget{namespace_assimp_a704d02684243c28d97f16184ca7da160}\label{namespace_assimp_a704d02684243c28d97f16184ca7da160}} 
{\footnotesize template$<$class char\+\_\+t $>$ }\\AI\+\_\+\+FORCE\+\_\+\+INLINE bool {\bfseries Is\+Upper} (char\+\_\+t in)
\item 
\mbox{\Hypertarget{namespace_assimp_a9b1362fc8d49819d06aae521117255aa}\label{namespace_assimp_a9b1362fc8d49819d06aae521117255aa}} 
{\footnotesize template$<$class char\+\_\+t $>$ }\\AI\+\_\+\+FORCE\+\_\+\+INLINE bool {\bfseries Is\+Lower} (char\+\_\+t in)
\item 
\mbox{\Hypertarget{namespace_assimp_a2dc3cfed4430c305908c17c403ced49c}\label{namespace_assimp_a2dc3cfed4430c305908c17c403ced49c}} 
{\footnotesize template$<$class char\+\_\+t $>$ }\\AI\+\_\+\+FORCE\+\_\+\+INLINE bool {\bfseries Is\+Space} (char\+\_\+t in)
\item 
\mbox{\Hypertarget{namespace_assimp_a99092e9b63e3e8bb88dc63e141d7157f}\label{namespace_assimp_a99092e9b63e3e8bb88dc63e141d7157f}} 
{\footnotesize template$<$class char\+\_\+t $>$ }\\AI\+\_\+\+FORCE\+\_\+\+INLINE bool {\bfseries Is\+Line\+End} (char\+\_\+t in)
\item 
\mbox{\Hypertarget{namespace_assimp_a3883df5611e6ba0bd986fd5694c47e35}\label{namespace_assimp_a3883df5611e6ba0bd986fd5694c47e35}} 
{\footnotesize template$<$class char\+\_\+t $>$ }\\AI\+\_\+\+FORCE\+\_\+\+INLINE bool {\bfseries Is\+Space\+Or\+New\+Line} (char\+\_\+t in)
\item 
\mbox{\Hypertarget{namespace_assimp_a77e1d122d82c1e0905f5dc37ca72c0dc}\label{namespace_assimp_a77e1d122d82c1e0905f5dc37ca72c0dc}} 
{\footnotesize template$<$class char\+\_\+t $>$ }\\AI\+\_\+\+FORCE\+\_\+\+INLINE bool {\bfseries Skip\+Spaces} (const char\+\_\+t $\ast$in, const char\+\_\+t $\ast$$\ast$out, const char\+\_\+t $\ast$end)
\item 
\mbox{\Hypertarget{namespace_assimp_a82f178242e797717fcf7ad931cb3a7bf}\label{namespace_assimp_a82f178242e797717fcf7ad931cb3a7bf}} 
{\footnotesize template$<$class char\+\_\+t $>$ }\\AI\+\_\+\+FORCE\+\_\+\+INLINE bool {\bfseries Skip\+Spaces} (const char\+\_\+t $\ast$$\ast$inout, const char\+\_\+t $\ast$end)
\item 
\mbox{\Hypertarget{namespace_assimp_a476258ae0b76954ccf1a95ab45305f58}\label{namespace_assimp_a476258ae0b76954ccf1a95ab45305f58}} 
{\footnotesize template$<$class char\+\_\+t $>$ }\\AI\+\_\+\+FORCE\+\_\+\+INLINE bool {\bfseries Skip\+Line} (const char\+\_\+t $\ast$in, const char\+\_\+t $\ast$$\ast$out, const char\+\_\+t $\ast$end)
\item 
\mbox{\Hypertarget{namespace_assimp_aa3487f7abed0522ea2b5690247003694}\label{namespace_assimp_aa3487f7abed0522ea2b5690247003694}} 
{\footnotesize template$<$class char\+\_\+t $>$ }\\AI\+\_\+\+FORCE\+\_\+\+INLINE bool {\bfseries Skip\+Line} (const char\+\_\+t $\ast$$\ast$inout, const char\+\_\+t $\ast$end)
\item 
\mbox{\Hypertarget{namespace_assimp_a7fded9895754c979f0755aab49b97fd2}\label{namespace_assimp_a7fded9895754c979f0755aab49b97fd2}} 
{\footnotesize template$<$class char\+\_\+t $>$ }\\AI\+\_\+\+FORCE\+\_\+\+INLINE bool {\bfseries Skip\+Spaces\+And\+Line\+End} (const char\+\_\+t $\ast$in, const char\+\_\+t $\ast$$\ast$out, const char\+\_\+t $\ast$end)
\item 
\mbox{\Hypertarget{namespace_assimp_a65ab3786f2d0ea7485330a326537c88d}\label{namespace_assimp_a65ab3786f2d0ea7485330a326537c88d}} 
{\footnotesize template$<$class char\+\_\+t $>$ }\\AI\+\_\+\+FORCE\+\_\+\+INLINE bool {\bfseries Skip\+Spaces\+And\+Line\+End} (const char\+\_\+t $\ast$$\ast$inout, const char\+\_\+t $\ast$end)
\item 
\mbox{\Hypertarget{namespace_assimp_afe5a72a3537a830b13ce020af6dd3161}\label{namespace_assimp_afe5a72a3537a830b13ce020af6dd3161}} 
{\footnotesize template$<$class char\+\_\+t $>$ }\\AI\+\_\+\+FORCE\+\_\+\+INLINE bool {\bfseries Get\+Next\+Line} (const char\+\_\+t $\ast$\&buffer, char\+\_\+t out\mbox{[}Buffer\+Size\mbox{]})
\item 
\mbox{\Hypertarget{namespace_assimp_a66776110eb3e45aecf16baebd71ca713}\label{namespace_assimp_a66776110eb3e45aecf16baebd71ca713}} 
{\footnotesize template$<$class char\+\_\+t $>$ }\\AI\+\_\+\+FORCE\+\_\+\+INLINE bool {\bfseries Is\+Numeric} (char\+\_\+t in)
\item 
\mbox{\Hypertarget{namespace_assimp_ae4567ff539c9f9fc2b63598edbd3d4be}\label{namespace_assimp_ae4567ff539c9f9fc2b63598edbd3d4be}} 
{\footnotesize template$<$class char\+\_\+t $>$ }\\AI\+\_\+\+FORCE\+\_\+\+INLINE bool {\bfseries Token\+Match} (char\+\_\+t $\ast$\&in, const char $\ast$token, unsigned int len)
\item 
AI\+\_\+\+FORCE\+\_\+\+INLINE bool \mbox{\hyperlink{namespace_assimp_a3bd333f65bd8da9590190ed27987e47f}{Token\+MatchI}} (const char $\ast$\&in, const char $\ast$token, unsigned int len)
\begin{DoxyCompactList}\small\item\em Case-\/ignoring version of Token\+Match. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_assimp_adfc8bd80961fc1047f705a80a80f3536}\label{namespace_assimp_adfc8bd80961fc1047f705a80a80f3536}} 
AI\+\_\+\+FORCE\+\_\+\+INLINE void {\bfseries Skip\+Token} (const char $\ast$\&in, const char $\ast$end)
\item 
\mbox{\Hypertarget{namespace_assimp_a17e1ae1e1c4b2e04771407f0ba0d205a}\label{namespace_assimp_a17e1ae1e1c4b2e04771407f0ba0d205a}} 
AI\+\_\+\+FORCE\+\_\+\+INLINE std\+::string {\bfseries Get\+Next\+Token} (const char $\ast$\&in, const char $\ast$end)
\item 
{\footnotesize template$<$class string\+\_\+type $>$ }\\AI\+\_\+\+FORCE\+\_\+\+INLINE unsigned int \mbox{\hyperlink{namespace_assimp_a0e0c2d9e4239076705ccee261d0c2e70}{tokenize}} (const string\+\_\+type \&str, std\+::vector$<$ string\+\_\+type $>$ \&tokens, const string\+\_\+type \&delimiters)
\begin{DoxyCompactList}\small\item\em Will perform a simple tokenize. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_assimp_a791c7116274a21bd2df15a70e3064676}\label{namespace_assimp_a791c7116274a21bd2df15a70e3064676}} 
std\+::string {\bfseries ai\+\_\+std\+Str\+To\+Lower} (const std\+::string \&str)
\item 
unsigned int \mbox{\hyperlink{namespace_assimp_a95de3dd4de6a42bfed3eb0a9fcea48be}{ASSIMP\+\_\+itoa10}} (char $\ast$out, unsigned int max, int32\+\_\+t number)
\begin{DoxyCompactList}\small\item\em itoa with a fixed base 10 \textquotesingle{}itoa\textquotesingle{} is not consistently available on all platforms so it is quite useful to have a small replacement function here. No need to use a full sprintf() if we just want to print a number ... \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_assimp_a780ce39f05ccc110f67a59dd76709112}\label{namespace_assimp_a780ce39f05ccc110f67a59dd76709112}} 
{\footnotesize template$<$size\+\_\+t length$>$ }\\unsigned int {\bfseries ASSIMP\+\_\+itoa10} (char(\&out)\mbox{[}length\mbox{]}, int32\+\_\+t number)
\begin{DoxyCompactList}\small\item\em itoa with a fixed base 10 (Secure template overload) The compiler should choose this function if he or she is able to determine the size of the array automatically. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{namespace_assimp_a72851b2740829d0e26ee31da7af20ce6}{ASSIMP\+\_\+stricmp}} (const char $\ast$s1, const char $\ast$s2)
\begin{DoxyCompactList}\small\item\em Helper function to do platform independent string comparison. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{namespace_assimp_abd7b0704eb33d941b05a778f916cf963}{ASSIMP\+\_\+stricmp}} (const std\+::string \&a, const std\+::string \&b)
\begin{DoxyCompactList}\small\item\em Case independent comparison of two std\+::strings. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{namespace_assimp_a5718d462fef0070afea1d4ac4e65d4d8}{ASSIMP\+\_\+strincmp}} (const char $\ast$s1, const char $\ast$s2, unsigned int n)
\begin{DoxyCompactList}\small\item\em Helper function to do platform independent string comparison. \end{DoxyCompactList}\item 
unsigned int \mbox{\hyperlink{namespace_assimp_a7f1165ac9e907c30dbbba7657c651b4e}{integer\+\_\+pow}} (unsigned int base, unsigned int power)
\begin{DoxyCompactList}\small\item\em Evaluates an integer power. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_assimp_a26ab9ab92b7b78ef60b4e63e0dbc2f75}\label{namespace_assimp_a26ab9ab92b7b78ef60b4e63e0dbc2f75}} 
AI\+\_\+\+FORCE\+\_\+\+INLINE \mbox{\hyperlink{struct_assimp_1_1_vertex}{Vertex}} {\bfseries operator+} (const \mbox{\hyperlink{struct_assimp_1_1_vertex}{Vertex}} \&v0, const \mbox{\hyperlink{struct_assimp_1_1_vertex}{Vertex}} \&v1)
\item 
\mbox{\Hypertarget{namespace_assimp_a3b3364133e7a8b1b96d5839dcd53611c}\label{namespace_assimp_a3b3364133e7a8b1b96d5839dcd53611c}} 
AI\+\_\+\+FORCE\+\_\+\+INLINE \mbox{\hyperlink{struct_assimp_1_1_vertex}{Vertex}} {\bfseries operator-\/} (const \mbox{\hyperlink{struct_assimp_1_1_vertex}{Vertex}} \&v0, const \mbox{\hyperlink{struct_assimp_1_1_vertex}{Vertex}} \&v1)
\item 
\mbox{\Hypertarget{namespace_assimp_adbfb0febd3f3ba7392e78ebd59f0c091}\label{namespace_assimp_adbfb0febd3f3ba7392e78ebd59f0c091}} 
AI\+\_\+\+FORCE\+\_\+\+INLINE \mbox{\hyperlink{struct_assimp_1_1_vertex}{Vertex}} {\bfseries operator$\ast$} (const \mbox{\hyperlink{struct_assimp_1_1_vertex}{Vertex}} \&v0, ai\+\_\+real f)
\item 
\mbox{\Hypertarget{namespace_assimp_aeb258dfba56a50f59690dcae90e3db04}\label{namespace_assimp_aeb258dfba56a50f59690dcae90e3db04}} 
AI\+\_\+\+FORCE\+\_\+\+INLINE \mbox{\hyperlink{struct_assimp_1_1_vertex}{Vertex}} {\bfseries operator/} (const \mbox{\hyperlink{struct_assimp_1_1_vertex}{Vertex}} \&v0, ai\+\_\+real f)
\item 
\mbox{\Hypertarget{namespace_assimp_ad44995399966da4737a2afbe30e5983d}\label{namespace_assimp_ad44995399966da4737a2afbe30e5983d}} 
AI\+\_\+\+FORCE\+\_\+\+INLINE \mbox{\hyperlink{struct_assimp_1_1_vertex}{Vertex}} {\bfseries operator$\ast$} (ai\+\_\+real f, const \mbox{\hyperlink{struct_assimp_1_1_vertex}{Vertex}} \&v0)
\item 
\mbox{\Hypertarget{namespace_assimp_a76632b7a46dd8f86685b963dac085363}\label{namespace_assimp_a76632b7a46dd8f86685b963dac085363}} 
std\+::string {\bfseries XMLEscape} (const std\+::string \&data)
\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
class ASSIMP\+\_\+\+API \mbox{\hyperlink{namespace_assimp_a81d358b0d2907db3ffe185d60f41aa83}{Export\+Properties}}
\item 
constexpr double \mbox{\hyperlink{namespace_assimp_abecb22a56df4788bcf7b994dfa67a218}{fast\+\_\+atof\+\_\+table}} \mbox{[}Num\+Items\mbox{]}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\mbox{\hyperlink{namespace_assimp}{Assimp}}\textquotesingle{}s CPP-\/\+API and all internal APIs 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespace_assimp_a0c3ea46ea110bbc5987def5503507112}\label{namespace_assimp_a0c3ea46ea110bbc5987def5503507112}} 
\index{Assimp@{Assimp}!aiCreateAnimMesh@{aiCreateAnimMesh}}
\index{aiCreateAnimMesh@{aiCreateAnimMesh}!Assimp@{Assimp}}
\doxysubsubsection{\texorpdfstring{aiCreateAnimMesh()}{aiCreateAnimMesh()}}
{\footnotesize\ttfamily ASSIMP\+\_\+\+API \mbox{\hyperlink{structai_anim_mesh}{ai\+Anim\+Mesh}} $\ast$ Assimp\+::ai\+Create\+Anim\+Mesh (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structai_mesh}{ai\+Mesh}} $\ast$}]{mesh,  }\item[{bool}]{need\+Positions = {\ttfamily true},  }\item[{bool}]{need\+Normals = {\ttfamily true},  }\item[{bool}]{need\+Tangents = {\ttfamily true},  }\item[{bool}]{need\+Colors = {\ttfamily true},  }\item[{bool}]{need\+Tex\+Coords = {\ttfamily true} }\end{DoxyParamCaption})}

Create \mbox{\hyperlink{structai_anim_mesh}{ai\+Anim\+Mesh}} from \mbox{\hyperlink{structai_mesh}{ai\+Mesh}}. 
\begin{DoxyParams}{Parameters}
{\em mesh} & The input mesh to create an animated mesh from. \\
\hline
{\em need\+Positions} & If true, positions will be copied from. \\
\hline
{\em need\+Normals} & If true, normals will be copied from. \\
\hline
{\em need\+Tangents} & If true, tangents and bitangents will be copied from. \\
\hline
{\em need\+Colors} & If true, colors will be copied from. \\
\hline
{\em need\+Tex\+Coords} & If true, tex\+Coords will be copied from. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The new created animated mesh. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespace_assimp_a95de3dd4de6a42bfed3eb0a9fcea48be}\label{namespace_assimp_a95de3dd4de6a42bfed3eb0a9fcea48be}} 
\index{Assimp@{Assimp}!ASSIMP\_itoa10@{ASSIMP\_itoa10}}
\index{ASSIMP\_itoa10@{ASSIMP\_itoa10}!Assimp@{Assimp}}
\doxysubsubsection{\texorpdfstring{ASSIMP\_itoa10()}{ASSIMP\_itoa10()}}
{\footnotesize\ttfamily unsigned int Assimp\+::\+ASSIMP\+\_\+itoa10 (\begin{DoxyParamCaption}\item[{char $\ast$}]{out,  }\item[{unsigned int}]{max,  }\item[{int32\+\_\+t}]{number }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



itoa with a fixed base 10 \textquotesingle{}itoa\textquotesingle{} is not consistently available on all platforms so it is quite useful to have a small replacement function here. No need to use a full sprintf() if we just want to print a number ... 


\begin{DoxyParams}{Parameters}
{\em out} & Output buffer \\
\hline
{\em max} & Maximum number of characters to be written, including \textquotesingle{}\textbackslash{}0\textquotesingle{}. This parameter may not be 0. \\
\hline
{\em number} & Number to be written \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Length of the output string, excluding the \textquotesingle{}\textbackslash{}0\textquotesingle{} 
\end{DoxyReturn}
\mbox{\Hypertarget{namespace_assimp_a72851b2740829d0e26ee31da7af20ce6}\label{namespace_assimp_a72851b2740829d0e26ee31da7af20ce6}} 
\index{Assimp@{Assimp}!ASSIMP\_stricmp@{ASSIMP\_stricmp}}
\index{ASSIMP\_stricmp@{ASSIMP\_stricmp}!Assimp@{Assimp}}
\doxysubsubsection{\texorpdfstring{ASSIMP\_stricmp()}{ASSIMP\_stricmp()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily int Assimp\+::\+ASSIMP\+\_\+stricmp (\begin{DoxyParamCaption}\item[{const char $\ast$}]{s1,  }\item[{const char $\ast$}]{s2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Helper function to do platform independent string comparison. 

This is required since stricmp() is not consistently available on all platforms. Some platforms use the \textquotesingle{}\+\_\+\textquotesingle{} prefix, others don\textquotesingle{}t even have such a function.


\begin{DoxyParams}{Parameters}
{\em s1} & First input string \\
\hline
{\em s2} & Second input string \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if the given strings are identical 
\end{DoxyReturn}
\mbox{\Hypertarget{namespace_assimp_abd7b0704eb33d941b05a778f916cf963}\label{namespace_assimp_abd7b0704eb33d941b05a778f916cf963}} 
\index{Assimp@{Assimp}!ASSIMP\_stricmp@{ASSIMP\_stricmp}}
\index{ASSIMP\_stricmp@{ASSIMP\_stricmp}!Assimp@{Assimp}}
\doxysubsubsection{\texorpdfstring{ASSIMP\_stricmp()}{ASSIMP\_stricmp()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily int Assimp\+::\+ASSIMP\+\_\+stricmp (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{a,  }\item[{const std\+::string \&}]{b }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Case independent comparison of two std\+::strings. 


\begin{DoxyParams}{Parameters}
{\em a} & First string \\
\hline
{\em b} & Second string \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if a == b 
\end{DoxyReturn}
\mbox{\Hypertarget{namespace_assimp_a5718d462fef0070afea1d4ac4e65d4d8}\label{namespace_assimp_a5718d462fef0070afea1d4ac4e65d4d8}} 
\index{Assimp@{Assimp}!ASSIMP\_strincmp@{ASSIMP\_strincmp}}
\index{ASSIMP\_strincmp@{ASSIMP\_strincmp}!Assimp@{Assimp}}
\doxysubsubsection{\texorpdfstring{ASSIMP\_strincmp()}{ASSIMP\_strincmp()}}
{\footnotesize\ttfamily int Assimp\+::\+ASSIMP\+\_\+strincmp (\begin{DoxyParamCaption}\item[{const char $\ast$}]{s1,  }\item[{const char $\ast$}]{s2,  }\item[{unsigned int}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Helper function to do platform independent string comparison. 

This is required since strincmp() is not consistently available on all platforms. Some platforms use the \textquotesingle{}\+\_\+\textquotesingle{} prefix, others don\textquotesingle{}t even have such a function.


\begin{DoxyParams}{Parameters}
{\em s1} & First input string \\
\hline
{\em s2} & Second input string \\
\hline
{\em n} & Maximum number of characters to compare \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if the given strings are identical 
\end{DoxyReturn}
\mbox{\Hypertarget{namespace_assimp_a896afdcb6c8dc97c0b85edd74793d191}\label{namespace_assimp_a896afdcb6c8dc97c0b85edd74793d191}} 
\index{Assimp@{Assimp}!defaultAiAssertHandler@{defaultAiAssertHandler}}
\index{defaultAiAssertHandler@{defaultAiAssertHandler}!Assimp@{Assimp}}
\doxysubsubsection{\texorpdfstring{defaultAiAssertHandler()}{defaultAiAssertHandler()}}
{\footnotesize\ttfamily AI\+\_\+\+WONT\+\_\+\+RETURN ASSIMP\+\_\+\+API void Assimp\+::default\+Ai\+Assert\+Handler (\begin{DoxyParamCaption}\item[{const char $\ast$}]{failed\+Expression,  }\item[{const char $\ast$}]{file,  }\item[{int}]{line }\end{DoxyParamCaption})}



This issues a message to stderr and calls abort. 

The assert handler which is set by default. \mbox{\Hypertarget{namespace_assimp_a4b486541edb9e5bdda47cb9e73f9e877}\label{namespace_assimp_a4b486541edb9e5bdda47cb9e73f9e877}} 
\index{Assimp@{Assimp}!fast\_atoreal\_move@{fast\_atoreal\_move}}
\index{fast\_atoreal\_move@{fast\_atoreal\_move}!Assimp@{Assimp}}
\doxysubsubsection{\texorpdfstring{fast\_atoreal\_move()}{fast\_atoreal\_move()}}
{\footnotesize\ttfamily template$<$typename Real , typename Exception\+Type  = Deadly\+Import\+Error$>$ \\
const char $\ast$ Assimp\+::fast\+\_\+atoreal\+\_\+move (\begin{DoxyParamCaption}\item[{const char $\ast$}]{c,  }\item[{Real \&}]{out,  }\item[{bool}]{check\+\_\+comma = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Provides a fast function for converting a string into a float, about 6 times faster than atof in win32. \mbox{\Hypertarget{namespace_assimp_a7f1165ac9e907c30dbbba7657c651b4e}\label{namespace_assimp_a7f1165ac9e907c30dbbba7657c651b4e}} 
\index{Assimp@{Assimp}!integer\_pow@{integer\_pow}}
\index{integer\_pow@{integer\_pow}!Assimp@{Assimp}}
\doxysubsubsection{\texorpdfstring{integer\_pow()}{integer\_pow()}}
{\footnotesize\ttfamily unsigned int Assimp\+::integer\+\_\+pow (\begin{DoxyParamCaption}\item[{unsigned int}]{base,  }\item[{unsigned int}]{power }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Evaluates an integer power. 

todo\+: move somewhere where it fits better in than here \mbox{\Hypertarget{namespace_assimp_a0e0c2d9e4239076705ccee261d0c2e70}\label{namespace_assimp_a0e0c2d9e4239076705ccee261d0c2e70}} 
\index{Assimp@{Assimp}!tokenize@{tokenize}}
\index{tokenize@{tokenize}!Assimp@{Assimp}}
\doxysubsubsection{\texorpdfstring{tokenize()}{tokenize()}}
{\footnotesize\ttfamily template$<$class string\+\_\+type $>$ \\
AI\+\_\+\+FORCE\+\_\+\+INLINE unsigned int Assimp\+::tokenize (\begin{DoxyParamCaption}\item[{const string\+\_\+type \&}]{str,  }\item[{std\+::vector$<$ string\+\_\+type $>$ \&}]{tokens,  }\item[{const string\+\_\+type \&}]{delimiters }\end{DoxyParamCaption})}



Will perform a simple tokenize. 


\begin{DoxyParams}{Parameters}
{\em str} & String to tokenize. \\
\hline
{\em tokens} & Array with tokens, will be empty if no token was found. \\
\hline
{\em delimiters} & Delimiter for tokenize. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of found token. 
\end{DoxyReturn}
\mbox{\Hypertarget{namespace_assimp_a3bd333f65bd8da9590190ed27987e47f}\label{namespace_assimp_a3bd333f65bd8da9590190ed27987e47f}} 
\index{Assimp@{Assimp}!TokenMatchI@{TokenMatchI}}
\index{TokenMatchI@{TokenMatchI}!Assimp@{Assimp}}
\doxysubsubsection{\texorpdfstring{TokenMatchI()}{TokenMatchI()}}
{\footnotesize\ttfamily AI\+\_\+\+FORCE\+\_\+\+INLINE bool Assimp\+::\+Token\+MatchI (\begin{DoxyParamCaption}\item[{const char $\ast$\&}]{in,  }\item[{const char $\ast$}]{token,  }\item[{unsigned int}]{len }\end{DoxyParamCaption})}



Case-\/ignoring version of Token\+Match. 


\begin{DoxyParams}{Parameters}
{\em in} & Input \\
\hline
{\em token} & Token to check for \\
\hline
{\em len} & Number of characters to check \\
\hline
\end{DoxyParams}


\doxysubsection{Variable Documentation}
\mbox{\Hypertarget{namespace_assimp_a81d358b0d2907db3ffe185d60f41aa83}\label{namespace_assimp_a81d358b0d2907db3ffe185d60f41aa83}} 
\index{Assimp@{Assimp}!ExportProperties@{ExportProperties}}
\index{ExportProperties@{ExportProperties}!Assimp@{Assimp}}
\doxysubsubsection{\texorpdfstring{ExportProperties}{ExportProperties}}
{\footnotesize\ttfamily class ASSIMP\+\_\+\+API \mbox{\hyperlink{class_assimp_1_1_export_properties}{Assimp\+::\+Export\+Properties}}}

CPP-\/\+API\+: The \mbox{\hyperlink{class_assimp_1_1_exporter}{Exporter}} class forms an C++ interface to the export functionality of the Open Asset Import Library. Note that the export interface is available only if \mbox{\hyperlink{namespace_assimp}{Assimp}} has been built with ASSIMP\+\_\+\+BUILD\+\_\+\+NO\+\_\+\+EXPORT not defined.

The interface is modeled after the importer interface and mostly symmetric. The same rules for threading etc. apply.

In a nutshell, there are two export interfaces\+: \#\+Export, which writes the output file(s) either to the regular file system or to a user-\/supplied \#\+IOSystem, and \#\+Export\+To\+Blob which returns a linked list of memory buffers (blob), each referring to one output file (in most cases there will be only one output file of course, but this extra complexity is needed since \mbox{\hyperlink{namespace_assimp}{Assimp}} aims at supporting a wide range of file formats).

\#\+Export\+To\+Blob is especially useful if you intend to work with the data in-\/memory. \mbox{\Hypertarget{namespace_assimp_abecb22a56df4788bcf7b994dfa67a218}\label{namespace_assimp_abecb22a56df4788bcf7b994dfa67a218}} 
\index{Assimp@{Assimp}!fast\_atof\_table@{fast\_atof\_table}}
\index{fast\_atof\_table@{fast\_atof\_table}!Assimp@{Assimp}}
\doxysubsubsection{\texorpdfstring{fast\_atof\_table}{fast\_atof\_table}}
{\footnotesize\ttfamily constexpr double Assimp\+::fast\+\_\+atof\+\_\+table\hspace{0.3cm}{\ttfamily [constexpr]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{=  \{  }
\DoxyCodeLine{    0.0,}
\DoxyCodeLine{    0.1,}
\DoxyCodeLine{    0.01,}
\DoxyCodeLine{    0.001,}
\DoxyCodeLine{    0.0001,}
\DoxyCodeLine{    0.00001,}
\DoxyCodeLine{    0.000001,}
\DoxyCodeLine{    0.0000001,}
\DoxyCodeLine{    0.00000001,}
\DoxyCodeLine{    0.000000001,}
\DoxyCodeLine{    0.0000000001,}
\DoxyCodeLine{    0.00000000001,}
\DoxyCodeLine{    0.000000000001,}
\DoxyCodeLine{    0.0000000000001,}
\DoxyCodeLine{    0.00000000000001,}
\DoxyCodeLine{    0.000000000000001}
\DoxyCodeLine{\}}

\end{DoxyCode}
